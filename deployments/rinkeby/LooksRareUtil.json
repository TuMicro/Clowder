{
  "address": "0x020f20a352BcA41A9334a512c3EeAd28860814D8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "collection",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "listPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expiration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "feesFraction",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "paymentToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "buildAndGetOpenSeaOrderHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "finalOrderHash",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isOrderAsk",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "collection",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "strategy",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "currency",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minPercentageToAsk",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "params",
              "type": "bytes"
            },
            {
              "internalType": "uint8",
              "name": "v",
              "type": "uint8"
            },
            {
              "internalType": "bytes32",
              "name": "r",
              "type": "bytes32"
            },
            {
              "internalType": "bytes32",
              "name": "s",
              "type": "bytes32"
            }
          ],
          "internalType": "struct LooksRareUtil.MakerOrder",
          "name": "order",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x86b715b0d72758aed8197ef6972bdbb369538aaf2b7eaa2e252645dc3ce40f4f",
  "receipt": {
    "to": null,
    "from": "0xC103d1b071AFA925714eE55b2F4869300C4331C4",
    "contractAddress": "0x020f20a352BcA41A9334a512c3EeAd28860814D8",
    "transactionIndex": 5,
    "gasUsed": "460124",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7d02416119dad7bb63a4d230cf35967aaf374c5fccd16d579cd9cb3ed7d0b0c3",
    "transactionHash": "0x86b715b0d72758aed8197ef6972bdbb369538aaf2b7eaa2e252645dc3ce40f4f",
    "logs": [],
    "blockNumber": 10783043,
    "cumulativeGasUsed": "834263",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "21dff2ffcfaa64fcc46cfa2256209c04",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feesFraction\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"buildAndGetOpenSeaOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"finalOrderHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isOrderAsk\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPercentageToAsk\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct LooksRareUtil.MakerOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/externalmarketplaces/LooksRareUtil.sol\":\"LooksRareUtil\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0d4de01fe5360c38b4ad2b0822a12722958428f5138a7ff47c1720eb6fa52bba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x3c07f43e60e099b3b157243b3152722e73b80eeb7985c2cd73712828d7f7da29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/libraries/externalmarketplaces/LooksRareUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\r\\n\\r\\nlibrary LooksRareUtil {\\r\\n    // rinkeby\\r\\n    address internal constant EXCHANGE =\\r\\n        0x1AA777972073Ff66DCFDeD85749bDD555C0665dA;\\r\\n    address internal constant TRANSFER_MANAGER_ERC721 =\\r\\n        0x3f65A762F15D01809cDC6B43d8849fF24949c86a;\\r\\n    address internal constant STRATEGY_STANDARD_SALE =\\r\\n        0x732319A3590E4fA838C111826f9584a9A2fDEa1a;\\r\\n    bytes32 internal constant DOMAIN_SEPARATOR = \\r\\n        0x6a8c50eacf3837f71a91496bc31832bb7e76c97cd16ce5830f970949edc565e5;\\r\\n\\r\\n    // mainnet\\r\\n    // address public constant EXCHANGE = 0x59728544B08AB483533076417FbBB2fD0B17CE3a;\\r\\n    // bytes32 internal constant DOMAIN_SEPARATOR = \\r\\n    //     0xad4d53a9c11a3edbe96e78e969291ab5248faeb3b8d4552c21e6bc72edb8cab3;\\r\\n    // ...\\r\\n\\r\\n    function initializationAndPermissions(address user, address erc721address)\\r\\n        public\\r\\n    {\\r\\n        IERC721 erc721 = IERC721(erc721address);\\r\\n        if (!erc721.isApprovedForAll(user, TRANSFER_MANAGER_ERC721)) {\\r\\n            erc721.setApprovalForAll(TRANSFER_MANAGER_ERC721, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function buildAndGetOpenSeaOrderHash(\\r\\n        address seller,\\r\\n        address collection,\\r\\n        uint256 tokenId,\\r\\n        uint256 listPrice, // to be paid by buyer, the amount the seller receives is affected by fees\\r\\n        uint256 expiration,\\r\\n        uint256 feesFraction, // (royalties + protocol fee fraction) out of 10_000\\r\\n        address paymentToken,\\r\\n        uint256 nonce\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            bytes32 finalOrderHash,\\r\\n            MakerOrder memory order\\r\\n        )\\r\\n    {\\r\\n        order = MakerOrder({\\r\\n          isOrderAsk: true,\\r\\n          signer: seller,\\r\\n          collection: collection,\\r\\n          price: listPrice,\\r\\n          tokenId: tokenId,\\r\\n          amount: 1, // we only support ERC721 for now\\r\\n          strategy: STRATEGY_STANDARD_SALE,\\r\\n          currency: paymentToken,\\r\\n          nonce: nonce,\\r\\n          startTime: block.timestamp,\\r\\n          endTime: expiration,\\r\\n          minPercentageToAsk: 10_000 - feesFraction,\\r\\n          params: \\\"\\\",\\r\\n\\r\\n          v: 0,\\r\\n          r: 0,\\r\\n          s: 0\\r\\n        });\\r\\n        finalOrderHash = ECDSA.toTypedDataHash(DOMAIN_SEPARATOR, hash(order));\\r\\n    }\\r\\n\\r\\n    // keccak256(\\\"MakerOrder(bool isOrderAsk,address signer,address collection,uint256 price,uint256 tokenId,uint256 amount,address strategy,address currency,uint256 nonce,uint256 startTime,uint256 endTime,uint256 minPercentageToAsk,bytes params)\\\")\\r\\n    bytes32 internal constant MAKER_ORDER_HASH =\\r\\n        0x40261ade532fa1d2c7293df30aaadb9b3c616fae525a0b56d3d411c841a85028;\\r\\n\\r\\n    struct MakerOrder {\\r\\n        bool isOrderAsk; // true --> ask / false --> bid\\r\\n        address signer; // signer of the maker order\\r\\n        address collection; // collection address\\r\\n        uint256 price; // price (used as )\\r\\n        uint256 tokenId; // id of the token\\r\\n        uint256 amount; // amount of tokens to sell/purchase (must be 1 for ERC721, 1+ for ERC1155)\\r\\n        address strategy; // strategy for trade execution (e.g., DutchAuction, StandardSaleForFixedPrice)\\r\\n        address currency; // currency (e.g., WETH)\\r\\n        uint256 nonce; // order nonce (must be unique unless new maker order is meant to override existing one e.g., lower ask price)\\r\\n        uint256 startTime; // startTime in timestamp\\r\\n        uint256 endTime; // endTime in timestamp\\r\\n        uint256 minPercentageToAsk; // slippage protection (9000 --> 90% of the final price must return to ask)\\r\\n        bytes params; // additional parameters\\r\\n        uint8 v; // v: parameter (27 or 28)\\r\\n        bytes32 r; // r: parameter\\r\\n        bytes32 s; // s: parameter\\r\\n    }\\r\\n\\r\\n    function hash(MakerOrder memory makerOrder)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    MAKER_ORDER_HASH,\\r\\n                    makerOrder.isOrderAsk,\\r\\n                    makerOrder.signer,\\r\\n                    makerOrder.collection,\\r\\n                    makerOrder.price,\\r\\n                    makerOrder.tokenId,\\r\\n                    makerOrder.amount,\\r\\n                    makerOrder.strategy,\\r\\n                    makerOrder.currency,\\r\\n                    makerOrder.nonce,\\r\\n                    makerOrder.startTime,\\r\\n                    makerOrder.endTime,\\r\\n                    makerOrder.minPercentageToAsk,\\r\\n                    keccak256(makerOrder.params)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xeeac9debcae648071c7bbe198ba9b230cd40d4ac7b177d3687f4061496fe0d6a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61075b61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80631221a1ca14610045578063748d237e1461006f575b600080fd5b61005861005336600461041a565b610091565b6040516100669291906104db565b60405180910390f35b81801561007b57600080fd5b5061008f61008a366004610611565b610252565b005b604080516102008101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201526101a081018290526101c081018290526101e081018290526040518061020001604052806001151581526020018b6001600160a01b031681526020018a6001600160a01b031681526020018881526020018981526020016001815260200173732319a3590e4fa838c111826f9584a9a2fdea1a6001600160a01b03168152602001856001600160a01b03168152602001848152602001428152602001878152602001866127106101a89190610644565b815260408051602081810183526000808352908401919091529082018190526060820181905260809091015290506102437f6a8c50eacf3837f71a91496bc31832bb7e76c97cd16ce5830f970949edc565e561020383610357565b60405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b91509850989650505050505050565b60405163e985e9c560e01b81526001600160a01b038381166004830152733f65a762f15d01809cdc6b43d8849ff24949c86a602483015282919082169063e985e9c590604401602060405180830381865afa1580156102b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d99190610669565b6103525760405163a22cb46560e01b8152733f65a762f15d01809cdc6b43d8849ff24949c86a6004820152600160248201526001600160a01b0382169063a22cb46590604401600060405180830381600087803b15801561033957600080fd5b505af115801561034d573d6000803e3d6000fd5b505050505b505050565b80516020808301516040808501516060860151608087015160a088015160c089015160e08a01516101008b01516101208c01516101408d01516101608e01516101808f01518051908e01209a5160009e6103e19e7f40261ade532fa1d2c7293df30aaadb9b3c616fae525a0b56d3d411c841a850289e919d919c9b9a999897969594939201610692565b604051602081830303815290604052805190602001209050919050565b80356001600160a01b038116811461041557600080fd5b919050565b600080600080600080600080610100898b03121561043757600080fd5b610440896103fe565b975061044e60208a016103fe565b965060408901359550606089013594506080890135935060a0890135925061047860c08a016103fe565b915060e089013590509295985092959890939650565b6000815180845260005b818110156104b457602081850181015186830182015201610498565b818111156104c6576000602083870101525b50601f01601f19169290920160200192915050565b828152604060208201526104f460408201835115159052565b6000602083015161051060608401826001600160a01b03169052565b5060408301516001600160a01b038116608084015250606083015160a0830152608083015160c083015260a083015160e083015260c0830151610100610560818501836001600160a01b03169052565b60e0850151915061012061057e818601846001600160a01b03169052565b908501516101408581019190915290850151610160808601919091529085015161018080860191909152908501516101a080860191909152908501516102006101c080870182905291935091906105d961024087018561048e565b918701519193506101e06105f18782018460ff169052565b908701519286019290925250909301516102209092019190915250919050565b6000806040838503121561062457600080fd5b61062d836103fe565b915061063b602084016103fe565b90509250929050565b60008282101561066457634e487b7160e01b600052601160045260246000fd5b500390565b60006020828403121561067b57600080fd5b8151801515811461068b57600080fd5b9392505050565b8e81528d151560208201526001600160a01b038d811660408301528c1660608201526101c081018b60808301528a60a08301528960c08301526106e060e083018a6001600160a01b03169052565b6001600160a01b0388166101008301526101208201969096526101408101949094526101608401929092526101808301526101a090910152999850505050505050505056fea264697066735822122070b69276f004b008e23ef17ff8c57360fd4fdb55d4745a3c00c52808b4a78ae364736f6c634300080d0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80631221a1ca14610045578063748d237e1461006f575b600080fd5b61005861005336600461041a565b610091565b6040516100669291906104db565b60405180910390f35b81801561007b57600080fd5b5061008f61008a366004610611565b610252565b005b604080516102008101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820183905260e0820183905261010082018390526101208201839052610140820183905261016082018390526101808201526101a081018290526101c081018290526101e081018290526040518061020001604052806001151581526020018b6001600160a01b031681526020018a6001600160a01b031681526020018881526020018981526020016001815260200173732319a3590e4fa838c111826f9584a9a2fdea1a6001600160a01b03168152602001856001600160a01b03168152602001848152602001428152602001878152602001866127106101a89190610644565b815260408051602081810183526000808352908401919091529082018190526060820181905260809091015290506102437f6a8c50eacf3837f71a91496bc31832bb7e76c97cd16ce5830f970949edc565e561020383610357565b60405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b91509850989650505050505050565b60405163e985e9c560e01b81526001600160a01b038381166004830152733f65a762f15d01809cdc6b43d8849ff24949c86a602483015282919082169063e985e9c590604401602060405180830381865afa1580156102b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d99190610669565b6103525760405163a22cb46560e01b8152733f65a762f15d01809cdc6b43d8849ff24949c86a6004820152600160248201526001600160a01b0382169063a22cb46590604401600060405180830381600087803b15801561033957600080fd5b505af115801561034d573d6000803e3d6000fd5b505050505b505050565b80516020808301516040808501516060860151608087015160a088015160c089015160e08a01516101008b01516101208c01516101408d01516101608e01516101808f01518051908e01209a5160009e6103e19e7f40261ade532fa1d2c7293df30aaadb9b3c616fae525a0b56d3d411c841a850289e919d919c9b9a999897969594939201610692565b604051602081830303815290604052805190602001209050919050565b80356001600160a01b038116811461041557600080fd5b919050565b600080600080600080600080610100898b03121561043757600080fd5b610440896103fe565b975061044e60208a016103fe565b965060408901359550606089013594506080890135935060a0890135925061047860c08a016103fe565b915060e089013590509295985092959890939650565b6000815180845260005b818110156104b457602081850181015186830182015201610498565b818111156104c6576000602083870101525b50601f01601f19169290920160200192915050565b828152604060208201526104f460408201835115159052565b6000602083015161051060608401826001600160a01b03169052565b5060408301516001600160a01b038116608084015250606083015160a0830152608083015160c083015260a083015160e083015260c0830151610100610560818501836001600160a01b03169052565b60e0850151915061012061057e818601846001600160a01b03169052565b908501516101408581019190915290850151610160808601919091529085015161018080860191909152908501516101a080860191909152908501516102006101c080870182905291935091906105d961024087018561048e565b918701519193506101e06105f18782018460ff169052565b908701519286019290925250909301516102209092019190915250919050565b6000806040838503121561062457600080fd5b61062d836103fe565b915061063b602084016103fe565b90509250929050565b60008282101561066457634e487b7160e01b600052601160045260246000fd5b500390565b60006020828403121561067b57600080fd5b8151801515811461068b57600080fd5b9392505050565b8e81528d151560208201526001600160a01b038d811660408301528c1660608201526101c081018b60808301528a60a08301528960c08301526106e060e083018a6001600160a01b03169052565b6001600160a01b0388166101008301526101208201969096526101408101949094526101608401929092526101808301526101a090910152999850505050505050505056fea264697066735822122070b69276f004b008e23ef17ff8c57360fd4fdb55d4745a3c00c52808b4a78ae364736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}